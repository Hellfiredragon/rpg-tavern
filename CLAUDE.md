# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

RPG Tavern is an LLM-powered RPG engine. Players connect, describe what their characters want to do, and the server uses LLMs to alter world state and narrate the story. Data is stored as files on disk.

## Tech Stack

- **Backend:** Python 3.12+ with FastAPI, managed by **uv**
- **Frontend:** React 19 + TypeScript with Vite, managed by **bun**
- Backend serves the built frontend as static files from `backend/static/`

## Commands

### Development

```bash
uv run main.py              # Start backend + frontend in watch mode
uv run main.py --demo       # Same, but wipe and recreate demo templates first
uv run main.py --data-dir /tmp/rpg  # Use a custom data directory
```

### Backend only

```bash
uv run uvicorn backend.app:app --reload --port 13013   # Start backend with hot-reload
uv add <package>                                        # Add a Python dependency
```

### Tests

```bash
uv run pytest                       # Run all tests
uv run pytest tests/test_storage.py # Run a single test file
uv run pytest -k test_create        # Run tests matching a pattern
```

### Frontend only

```bash
cd frontend && bun run dev       # Vite dev server (proxies /api → backend)
cd frontend && bun run build     # Build to backend/static/
cd frontend && bun run lint      # ESLint
```

## Architecture

```
backend/              Python backend (FastAPI)
  app.py              App factory (create_app with configurable data_dir)
  routes.py           API endpoints under /api (/templates, /adventures, /personas, /settings, /name-suggestion, /lorebook)
  pipeline.py         Intention/resolution chat pipeline (run_pipeline, parser, extractors, persona integration)
  storage.py          File-based JSON storage (split templates + adventures, preset merging, config, lorebook, personas)
  prompts.py          Handlebars prompt rendering + context builder for story roles
  characters.py       Character state logic (categories, thresholds, ticking, activation, prompt context)
  lorebook.py         Lorebook keyword matching and formatting
  demo.py             Demo data generator (--demo flag)
  static/             Built frontend assets (gitignored, generated by `bun run build`)

frontend/             React + TypeScript (Vite)
  src/
    App.tsx            URL router (see "Frontend Routes" below)
    Layout.tsx         Shell with header breadcrumb (adventure name + back link)
    QuestBoard.tsx     Quest board with "Running Adventures" and "Templates" sections
    AdventureView.tsx  Tab-based view (Chat/Personas/Characters/World/Settings/Global Settings) for template or adventure
    EmbarkDialog.tsx   Modal dialog for naming an adventure before embarking
    AppSettings.tsx    Global settings (LLM connections, story role assignments, display, fonts)
    fontSettings.ts    Font list, types, and applyFontSettings() utility
    types.ts           Shared types (Character, Persona, StoryRoles, state constants/helpers)
    components/
      AddStateInput.tsx        Inline form for adding a state entry
      useEntityStates.ts       Hook: removeState/addState/changeStateValue (shared by character + persona panels)
      StateEditor.tsx          Renders core/persistent/temporal state sections with inputs
      CollapsibleCard.tsx      Expandable card wrapper (name, badges, state count)
      PersonaPanel.tsx         Unified persona panel (adventureSlug? prop → adventure or global mode)
      CharacterPanel.tsx       Character list with states, nicknames, chattiness
      LorebookPanel.tsx        Lorebook entry CRUD
      StoryRoleCard.tsx        Prompt editor card for a single story role
      PromptHintsPanel.tsx     Sliding help panel with template variable reference
      StatusTabs.tsx           Floating connection status indicators
      TemplateSettingsPanel.tsx Template intro text editor
  vite.config.ts      Build output → ../backend/static, dev proxy /api → backend

presets/              Built-in content (committed to git, read-only at runtime)
  templates/           Preset templates (merged with user templates, copy-on-write)
  adventure-names.txt  Name generation word lists (periods + epithets)

data/                 Runtime data storage (gitignored, default location)
  templates/           User-created and overridden templates
  adventures/          Running adventures (created via embark)
  personas.json        Global personas (array)
data-tests/           Test data (gitignored, wiped before each test)
.env.example          Default config (copy to .env to override)
ARCH-DESIGN.md        Data model and object tree storage design
```

### Configuration (.env)

All ports/host are configured via `.env` at the project root (see `.env.example`). Vite reads it via `loadEnv()`, Python via `python-dotenv`. Key vars: `HOST`, `BACKEND_PORT`, `FRONTEND_PORT`, `DATA_DIR`.

### Data storage

Objects are stored as a tree on disk — see [ARCH-DESIGN.md](ARCH-DESIGN.md) for the full model. Each object has a title slugified to an ASCII path (`"The Cursed Tavern"` → `the-cursed-tavern`). Data lives in `<slug>.json`, children in `<slug>/`. No IDs or UUIDs — the path is the reference.

Templates and adventures are stored in separate directories:
- `data/templates/` — user-created templates (+ copy-on-write overrides of presets)
- `data/adventures/` — running adventures (created by embarking from a template)
- `presets/templates/` — built-in templates (read-only, committed to git, merged at read time)

Configurable via `DATA_DIR` env or `--data-dir` flag. Tests use `data-tests/` which is wiped before each test run.

### Icons

Use **Font Awesome Free** (`@fortawesome/fontawesome-free`) for all icons. Prefer `fa-solid` style. Usage: `<i className="fa-solid fa-gear" />`. Do not use inline SVGs or Unicode symbols for icons. The CSS is imported in `main.tsx`.

### Frontend Routes

| Route | Page |
|-------|------|
| `/` | Quest Board |
| `/global-settings` | Standalone Global Settings |
| `/tmpl/{slug}` | Template (default tab: chat) |
| `/tmpl/{slug}/{tab}` | Template with specific tab |
| `/advn/{slug}` | Adventure (default tab: chat) |
| `/advn/{slug}/{tab}` | Adventure with specific tab |

Valid tabs: `chat`, `personas` (adventures only), `characters` (adventures only), `world`, `settings`, `global-settings`, `global-personas`. The tab bar is split into left (adventure-specific) and right (global) groups. The active tab is reflected in the URL via `history.replaceState` and restored on page load.

### UI Settings

All UI-related settings (layout dimensions, panel sizes, display preferences) belong in Global Settings under the "UI Settings" section. These are stored in `data/config.json` via the `GET/PATCH /api/settings` endpoints and managed in `AppSettings.tsx`.

**Font Settings** — configurable per-group typography stored in `config.json` under `font_settings`. Five groups: `narration`, `dialog`, `intention`, `heading`, `ui`. Each has `family` (from curated Google Fonts list), `size` (px), and `style` (normal/italic). Applied live via CSS custom properties (`--font-{group}-family`, `--font-{group}-size`, `--font-{group}-style`). Legacy `--font-heading` and `--font-body` kept as aliases. Font list and apply logic in `frontend/src/fontSettings.ts`. Settings applied on page load in `Layout.tsx` and live in `AppSettings.tsx`.

### Chat Pipeline (Intention/Resolution)

The chat pipeline in `backend/pipeline.py` uses an intention/resolution loop:

1. **Player intention** → Narrator resolves → segments (narration + dialog)
2. **Character extractor** runs for each character named in the narration
3. **Round loop** (up to `max_rounds`, default 3):
   - Activate characters (name matching + chattiness roll)
   - Each active character generates an **intention** (1 LLM call)
   - Narrator **resolves** the intention → segments (1 LLM call)
   - Character extractor updates that character's states (1 LLM call)
4. **Lorebook extractor** runs once per turn for new world facts
5. Tick all character + persona states, combine all segments into one narrator message

**Story Roles** (4 roles, each with a prompt template and LLM connection assignment):

| Role | Purpose |
|------|---------|
| `narrator` | Resolves intentions → narration + dialog |
| `character_intention` | Generates character intentions |
| `extractor` | Updates character states after each resolution |
| `lorebook_extractor` | Extracts new world facts |

**Connection assignments** — each role's LLM connection is stored per-adventure in `story-roles.json` (alongside the prompt). On embark, connections are copied from global defaults (`config.json` → `story_roles`). The pipeline resolves connections per-adventure first, falling back to global config. The adventure Settings tab shows a connection dropdown on each StoryRoleCard. Global Settings shows "Default Story Role Connections" for new adventures.

**Player name** — adventures store `player_name` (optional). The pipeline passes it as `{{player_name}}` to all prompts (fallback: "the adventurer"). The player name is also added to `known_names` for dialog parsing, so `Joe(surprised): text` is parsed as dialog. Editable in Embark dialog. `PATCH /api/adventures/{slug}` updates it.

**Personas** — player character profiles with description, nicknames, and states (same mechanics as NPC characters). Stored globally (`data/personas.json`) and per-adventure (`adventures/{slug}/personas.json`), with adventure-local winning by slug. When `active_persona` is set on an adventure, the persona name overrides `player_name`, persona nicknames join `known_names`, and `{{player.description}}`/`{{player.states}}` are available in templates. The character extractor also runs on the active persona when its name appears in narration (copy-on-write to adventure-local). Persona states are ticked each turn. Selectable via dropdown in the chat input bar. Manageable in the Personas tab.

**Narrator output format** — parsed by `parse_narrator_output()`:
```
Narration text here.
CharacterName(emotion): Dialog text here.
More narration.
```

**Message format** — messages have a `segments` field for structured rendering:
```json
{"role": "narrator", "text": "raw text", "segments": [{"type": "narration", "text": "..."}, {"type": "dialog", "character": "Name", "emotion": "happy", "text": "..."}]}
```

Frontend renders segments as inline dialog cards within narration. Falls back to plain `text` for old messages without segments.

**Sandbox mode** — per-adventure toggle shows character intention messages in chat.

### Dev proxy setup

In development, the Vite dev server proxies `/api/*` requests to the backend. In production, the backend serves everything — API routes and static frontend files — from a single port.

## Workflow

- After completing a piece of work, write the commit message into `.gitmessage` — this includes doc-only changes (CLAUDE.md, ARCH-DESIGN.md, etc.)
- **Commit messages** use semantic prefixes: `feat(topic):`, `fix(topic):`, `chore(topic):`, `refactor(topic):`, `test(topic):`, `docs(topic):`
- Keep TODOS.md updated when completing items listed there
- Update CLAUDE.md
- Update `backend/demo.py` when data model or storage changes so `--demo` generates valid, representative demo data
- Run `git done` when work is done — this stages all changes, commits with `.gitmessage`, and pushes